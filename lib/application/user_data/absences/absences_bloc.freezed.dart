// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'absences_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$AbsencesEventTearOff {
  const _$AbsencesEventTearOff();

  _getSmallWidget getSmallWidget() {
    return const _getSmallWidget();
  }

  _getFullWidget getFullWidget() {
    return const _getFullWidget();
  }

  _getOnlyAbsences getOnlyAbsences() {
    return const _getOnlyAbsences();
  }

  _getOnlySimpleLates getOnlySimpleLates() {
    return const _getOnlySimpleLates();
  }

  _getOnlyCompleteLates getOnlyCompleteLates() {
    return const _getOnlyCompleteLates();
  }

  _AbsencesReceived absencesReceived(
      Either<CVApiFailure, KtList<Absence>> failureOrAbsences) {
    return _AbsencesReceived(
      failureOrAbsences,
    );
  }
}

// ignore: unused_element
const $AbsencesEvent = _$AbsencesEventTearOff();

mixin _$AbsencesEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  });
}

abstract class $AbsencesEventCopyWith<$Res> {
  factory $AbsencesEventCopyWith(
          AbsencesEvent value, $Res Function(AbsencesEvent) then) =
      _$AbsencesEventCopyWithImpl<$Res>;
}

class _$AbsencesEventCopyWithImpl<$Res>
    implements $AbsencesEventCopyWith<$Res> {
  _$AbsencesEventCopyWithImpl(this._value, this._then);

  final AbsencesEvent _value;
  // ignore: unused_field
  final $Res Function(AbsencesEvent) _then;
}

abstract class _$getSmallWidgetCopyWith<$Res> {
  factory _$getSmallWidgetCopyWith(
          _getSmallWidget value, $Res Function(_getSmallWidget) then) =
      __$getSmallWidgetCopyWithImpl<$Res>;
}

class __$getSmallWidgetCopyWithImpl<$Res>
    extends _$AbsencesEventCopyWithImpl<$Res>
    implements _$getSmallWidgetCopyWith<$Res> {
  __$getSmallWidgetCopyWithImpl(
      _getSmallWidget _value, $Res Function(_getSmallWidget) _then)
      : super(_value, (v) => _then(v as _getSmallWidget));

  @override
  _getSmallWidget get _value => super._value as _getSmallWidget;
}

class _$_getSmallWidget
    with DiagnosticableTreeMixin
    implements _getSmallWidget {
  const _$_getSmallWidget();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesEvent.getSmallWidget()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesEvent.getSmallWidget'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getSmallWidget);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getSmallWidget();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getSmallWidget != null) {
      return getSmallWidget();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getSmallWidget(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getSmallWidget != null) {
      return getSmallWidget(this);
    }
    return orElse();
  }
}

abstract class _getSmallWidget implements AbsencesEvent {
  const factory _getSmallWidget() = _$_getSmallWidget;
}

abstract class _$getFullWidgetCopyWith<$Res> {
  factory _$getFullWidgetCopyWith(
          _getFullWidget value, $Res Function(_getFullWidget) then) =
      __$getFullWidgetCopyWithImpl<$Res>;
}

class __$getFullWidgetCopyWithImpl<$Res>
    extends _$AbsencesEventCopyWithImpl<$Res>
    implements _$getFullWidgetCopyWith<$Res> {
  __$getFullWidgetCopyWithImpl(
      _getFullWidget _value, $Res Function(_getFullWidget) _then)
      : super(_value, (v) => _then(v as _getFullWidget));

  @override
  _getFullWidget get _value => super._value as _getFullWidget;
}

class _$_getFullWidget with DiagnosticableTreeMixin implements _getFullWidget {
  const _$_getFullWidget();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesEvent.getFullWidget()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'AbsencesEvent.getFullWidget'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getFullWidget);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getFullWidget();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getFullWidget != null) {
      return getFullWidget();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getFullWidget(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getFullWidget != null) {
      return getFullWidget(this);
    }
    return orElse();
  }
}

abstract class _getFullWidget implements AbsencesEvent {
  const factory _getFullWidget() = _$_getFullWidget;
}

abstract class _$getOnlyAbsencesCopyWith<$Res> {
  factory _$getOnlyAbsencesCopyWith(
          _getOnlyAbsences value, $Res Function(_getOnlyAbsences) then) =
      __$getOnlyAbsencesCopyWithImpl<$Res>;
}

class __$getOnlyAbsencesCopyWithImpl<$Res>
    extends _$AbsencesEventCopyWithImpl<$Res>
    implements _$getOnlyAbsencesCopyWith<$Res> {
  __$getOnlyAbsencesCopyWithImpl(
      _getOnlyAbsences _value, $Res Function(_getOnlyAbsences) _then)
      : super(_value, (v) => _then(v as _getOnlyAbsences));

  @override
  _getOnlyAbsences get _value => super._value as _getOnlyAbsences;
}

class _$_getOnlyAbsences
    with DiagnosticableTreeMixin
    implements _getOnlyAbsences {
  const _$_getOnlyAbsences();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesEvent.getOnlyAbsences()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesEvent.getOnlyAbsences'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getOnlyAbsences);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getOnlyAbsences();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getOnlyAbsences != null) {
      return getOnlyAbsences();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getOnlyAbsences(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getOnlyAbsences != null) {
      return getOnlyAbsences(this);
    }
    return orElse();
  }
}

abstract class _getOnlyAbsences implements AbsencesEvent {
  const factory _getOnlyAbsences() = _$_getOnlyAbsences;
}

abstract class _$getOnlySimpleLatesCopyWith<$Res> {
  factory _$getOnlySimpleLatesCopyWith(
          _getOnlySimpleLates value, $Res Function(_getOnlySimpleLates) then) =
      __$getOnlySimpleLatesCopyWithImpl<$Res>;
}

class __$getOnlySimpleLatesCopyWithImpl<$Res>
    extends _$AbsencesEventCopyWithImpl<$Res>
    implements _$getOnlySimpleLatesCopyWith<$Res> {
  __$getOnlySimpleLatesCopyWithImpl(
      _getOnlySimpleLates _value, $Res Function(_getOnlySimpleLates) _then)
      : super(_value, (v) => _then(v as _getOnlySimpleLates));

  @override
  _getOnlySimpleLates get _value => super._value as _getOnlySimpleLates;
}

class _$_getOnlySimpleLates
    with DiagnosticableTreeMixin
    implements _getOnlySimpleLates {
  const _$_getOnlySimpleLates();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesEvent.getOnlySimpleLates()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesEvent.getOnlySimpleLates'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getOnlySimpleLates);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getOnlySimpleLates();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getOnlySimpleLates != null) {
      return getOnlySimpleLates();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getOnlySimpleLates(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getOnlySimpleLates != null) {
      return getOnlySimpleLates(this);
    }
    return orElse();
  }
}

abstract class _getOnlySimpleLates implements AbsencesEvent {
  const factory _getOnlySimpleLates() = _$_getOnlySimpleLates;
}

abstract class _$getOnlyCompleteLatesCopyWith<$Res> {
  factory _$getOnlyCompleteLatesCopyWith(_getOnlyCompleteLates value,
          $Res Function(_getOnlyCompleteLates) then) =
      __$getOnlyCompleteLatesCopyWithImpl<$Res>;
}

class __$getOnlyCompleteLatesCopyWithImpl<$Res>
    extends _$AbsencesEventCopyWithImpl<$Res>
    implements _$getOnlyCompleteLatesCopyWith<$Res> {
  __$getOnlyCompleteLatesCopyWithImpl(
      _getOnlyCompleteLates _value, $Res Function(_getOnlyCompleteLates) _then)
      : super(_value, (v) => _then(v as _getOnlyCompleteLates));

  @override
  _getOnlyCompleteLates get _value => super._value as _getOnlyCompleteLates;
}

class _$_getOnlyCompleteLates
    with DiagnosticableTreeMixin
    implements _getOnlyCompleteLates {
  const _$_getOnlyCompleteLates();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesEvent.getOnlyCompleteLates()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesEvent.getOnlyCompleteLates'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _getOnlyCompleteLates);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getOnlyCompleteLates();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getOnlyCompleteLates != null) {
      return getOnlyCompleteLates();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return getOnlyCompleteLates(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (getOnlyCompleteLates != null) {
      return getOnlyCompleteLates(this);
    }
    return orElse();
  }
}

abstract class _getOnlyCompleteLates implements AbsencesEvent {
  const factory _getOnlyCompleteLates() = _$_getOnlyCompleteLates;
}

abstract class _$AbsencesReceivedCopyWith<$Res> {
  factory _$AbsencesReceivedCopyWith(
          _AbsencesReceived value, $Res Function(_AbsencesReceived) then) =
      __$AbsencesReceivedCopyWithImpl<$Res>;
  $Res call({Either<CVApiFailure, KtList<Absence>> failureOrAbsences});
}

class __$AbsencesReceivedCopyWithImpl<$Res>
    extends _$AbsencesEventCopyWithImpl<$Res>
    implements _$AbsencesReceivedCopyWith<$Res> {
  __$AbsencesReceivedCopyWithImpl(
      _AbsencesReceived _value, $Res Function(_AbsencesReceived) _then)
      : super(_value, (v) => _then(v as _AbsencesReceived));

  @override
  _AbsencesReceived get _value => super._value as _AbsencesReceived;

  @override
  $Res call({
    Object failureOrAbsences = freezed,
  }) {
    return _then(_AbsencesReceived(
      failureOrAbsences == freezed
          ? _value.failureOrAbsences
          : failureOrAbsences as Either<CVApiFailure, KtList<Absence>>,
    ));
  }
}

class _$_AbsencesReceived
    with DiagnosticableTreeMixin
    implements _AbsencesReceived {
  const _$_AbsencesReceived(this.failureOrAbsences)
      : assert(failureOrAbsences != null);

  @override
  final Either<CVApiFailure, KtList<Absence>> failureOrAbsences;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesEvent.absencesReceived(failureOrAbsences: $failureOrAbsences)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesEvent.absencesReceived'))
      ..add(DiagnosticsProperty('failureOrAbsences', failureOrAbsences));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AbsencesReceived &&
            (identical(other.failureOrAbsences, failureOrAbsences) ||
                const DeepCollectionEquality()
                    .equals(other.failureOrAbsences, failureOrAbsences)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failureOrAbsences);

  @override
  _$AbsencesReceivedCopyWith<_AbsencesReceived> get copyWith =>
      __$AbsencesReceivedCopyWithImpl<_AbsencesReceived>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result getSmallWidget(),
    @required Result getFullWidget(),
    @required Result getOnlyAbsences(),
    @required Result getOnlySimpleLates(),
    @required Result getOnlyCompleteLates(),
    @required
        Result absencesReceived(
            Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return absencesReceived(failureOrAbsences);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result getSmallWidget(),
    Result getFullWidget(),
    Result getOnlyAbsences(),
    Result getOnlySimpleLates(),
    Result getOnlyCompleteLates(),
    Result absencesReceived(
        Either<CVApiFailure, KtList<Absence>> failureOrAbsences),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (absencesReceived != null) {
      return absencesReceived(failureOrAbsences);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result getSmallWidget(_getSmallWidget value),
    @required Result getFullWidget(_getFullWidget value),
    @required Result getOnlyAbsences(_getOnlyAbsences value),
    @required Result getOnlySimpleLates(_getOnlySimpleLates value),
    @required Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    @required Result absencesReceived(_AbsencesReceived value),
  }) {
    assert(getSmallWidget != null);
    assert(getFullWidget != null);
    assert(getOnlyAbsences != null);
    assert(getOnlySimpleLates != null);
    assert(getOnlyCompleteLates != null);
    assert(absencesReceived != null);
    return absencesReceived(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result getSmallWidget(_getSmallWidget value),
    Result getFullWidget(_getFullWidget value),
    Result getOnlyAbsences(_getOnlyAbsences value),
    Result getOnlySimpleLates(_getOnlySimpleLates value),
    Result getOnlyCompleteLates(_getOnlyCompleteLates value),
    Result absencesReceived(_AbsencesReceived value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (absencesReceived != null) {
      return absencesReceived(this);
    }
    return orElse();
  }
}

abstract class _AbsencesReceived implements AbsencesEvent {
  const factory _AbsencesReceived(
          Either<CVApiFailure, KtList<Absence>> failureOrAbsences) =
      _$_AbsencesReceived;

  Either<CVApiFailure, KtList<Absence>> get failureOrAbsences;
  _$AbsencesReceivedCopyWith<_AbsencesReceived> get copyWith;
}

class _$AbsencesStateTearOff {
  const _$AbsencesStateTearOff();

  Initial initial() {
    return const Initial();
  }

  LoadInProgress loadInProgress() {
    return const LoadInProgress();
  }

  LoadSuccess loadSuccess(KtList<Absence> absences) {
    return LoadSuccess(
      absences,
    );
  }

  LoadFailure loadFailure(CVApiFailure cvApiFailure) {
    return LoadFailure(
      cvApiFailure,
    );
  }
}

// ignore: unused_element
const $AbsencesState = _$AbsencesStateTearOff();

mixin _$AbsencesState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(KtList<Absence> absences),
    @required Result loadFailure(CVApiFailure cvApiFailure),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(KtList<Absence> absences),
    Result loadFailure(CVApiFailure cvApiFailure),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(Initial value),
    @required Result loadInProgress(LoadInProgress value),
    @required Result loadSuccess(LoadSuccess value),
    @required Result loadFailure(LoadFailure value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(Initial value),
    Result loadInProgress(LoadInProgress value),
    Result loadSuccess(LoadSuccess value),
    Result loadFailure(LoadFailure value),
    @required Result orElse(),
  });
}

abstract class $AbsencesStateCopyWith<$Res> {
  factory $AbsencesStateCopyWith(
          AbsencesState value, $Res Function(AbsencesState) then) =
      _$AbsencesStateCopyWithImpl<$Res>;
}

class _$AbsencesStateCopyWithImpl<$Res>
    implements $AbsencesStateCopyWith<$Res> {
  _$AbsencesStateCopyWithImpl(this._value, this._then);

  final AbsencesState _value;
  // ignore: unused_field
  final $Res Function(AbsencesState) _then;
}

abstract class $InitialCopyWith<$Res> {
  factory $InitialCopyWith(Initial value, $Res Function(Initial) then) =
      _$InitialCopyWithImpl<$Res>;
}

class _$InitialCopyWithImpl<$Res> extends _$AbsencesStateCopyWithImpl<$Res>
    implements $InitialCopyWith<$Res> {
  _$InitialCopyWithImpl(Initial _value, $Res Function(Initial) _then)
      : super(_value, (v) => _then(v as Initial));

  @override
  Initial get _value => super._value as Initial;
}

class _$Initial with DiagnosticableTreeMixin implements Initial {
  const _$Initial();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'AbsencesState.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(KtList<Absence> absences),
    @required Result loadFailure(CVApiFailure cvApiFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(KtList<Absence> absences),
    Result loadFailure(CVApiFailure cvApiFailure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(Initial value),
    @required Result loadInProgress(LoadInProgress value),
    @required Result loadSuccess(LoadSuccess value),
    @required Result loadFailure(LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(Initial value),
    Result loadInProgress(LoadInProgress value),
    Result loadSuccess(LoadSuccess value),
    Result loadFailure(LoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements AbsencesState {
  const factory Initial() = _$Initial;
}

abstract class $LoadInProgressCopyWith<$Res> {
  factory $LoadInProgressCopyWith(
          LoadInProgress value, $Res Function(LoadInProgress) then) =
      _$LoadInProgressCopyWithImpl<$Res>;
}

class _$LoadInProgressCopyWithImpl<$Res>
    extends _$AbsencesStateCopyWithImpl<$Res>
    implements $LoadInProgressCopyWith<$Res> {
  _$LoadInProgressCopyWithImpl(
      LoadInProgress _value, $Res Function(LoadInProgress) _then)
      : super(_value, (v) => _then(v as LoadInProgress));

  @override
  LoadInProgress get _value => super._value as LoadInProgress;
}

class _$LoadInProgress with DiagnosticableTreeMixin implements LoadInProgress {
  const _$LoadInProgress();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesState.loadInProgress()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesState.loadInProgress'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoadInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(KtList<Absence> absences),
    @required Result loadFailure(CVApiFailure cvApiFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(KtList<Absence> absences),
    Result loadFailure(CVApiFailure cvApiFailure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(Initial value),
    @required Result loadInProgress(LoadInProgress value),
    @required Result loadSuccess(LoadSuccess value),
    @required Result loadFailure(LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(Initial value),
    Result loadInProgress(LoadInProgress value),
    Result loadSuccess(LoadSuccess value),
    Result loadFailure(LoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress(this);
    }
    return orElse();
  }
}

abstract class LoadInProgress implements AbsencesState {
  const factory LoadInProgress() = _$LoadInProgress;
}

abstract class $LoadSuccessCopyWith<$Res> {
  factory $LoadSuccessCopyWith(
          LoadSuccess value, $Res Function(LoadSuccess) then) =
      _$LoadSuccessCopyWithImpl<$Res>;
  $Res call({KtList<Absence> absences});
}

class _$LoadSuccessCopyWithImpl<$Res> extends _$AbsencesStateCopyWithImpl<$Res>
    implements $LoadSuccessCopyWith<$Res> {
  _$LoadSuccessCopyWithImpl(
      LoadSuccess _value, $Res Function(LoadSuccess) _then)
      : super(_value, (v) => _then(v as LoadSuccess));

  @override
  LoadSuccess get _value => super._value as LoadSuccess;

  @override
  $Res call({
    Object absences = freezed,
  }) {
    return _then(LoadSuccess(
      absences == freezed ? _value.absences : absences as KtList<Absence>,
    ));
  }
}

class _$LoadSuccess with DiagnosticableTreeMixin implements LoadSuccess {
  const _$LoadSuccess(this.absences) : assert(absences != null);

  @override
  final KtList<Absence> absences;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesState.loadSuccess(absences: $absences)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesState.loadSuccess'))
      ..add(DiagnosticsProperty('absences', absences));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoadSuccess &&
            (identical(other.absences, absences) ||
                const DeepCollectionEquality()
                    .equals(other.absences, absences)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(absences);

  @override
  $LoadSuccessCopyWith<LoadSuccess> get copyWith =>
      _$LoadSuccessCopyWithImpl<LoadSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(KtList<Absence> absences),
    @required Result loadFailure(CVApiFailure cvApiFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(absences);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(KtList<Absence> absences),
    Result loadFailure(CVApiFailure cvApiFailure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(absences);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(Initial value),
    @required Result loadInProgress(LoadInProgress value),
    @required Result loadSuccess(LoadSuccess value),
    @required Result loadFailure(LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(Initial value),
    Result loadInProgress(LoadInProgress value),
    Result loadSuccess(LoadSuccess value),
    Result loadFailure(LoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(this);
    }
    return orElse();
  }
}

abstract class LoadSuccess implements AbsencesState {
  const factory LoadSuccess(KtList<Absence> absences) = _$LoadSuccess;

  KtList<Absence> get absences;
  $LoadSuccessCopyWith<LoadSuccess> get copyWith;
}

abstract class $LoadFailureCopyWith<$Res> {
  factory $LoadFailureCopyWith(
          LoadFailure value, $Res Function(LoadFailure) then) =
      _$LoadFailureCopyWithImpl<$Res>;
  $Res call({CVApiFailure cvApiFailure});

  $CVApiFailureCopyWith<$Res> get cvApiFailure;
}

class _$LoadFailureCopyWithImpl<$Res> extends _$AbsencesStateCopyWithImpl<$Res>
    implements $LoadFailureCopyWith<$Res> {
  _$LoadFailureCopyWithImpl(
      LoadFailure _value, $Res Function(LoadFailure) _then)
      : super(_value, (v) => _then(v as LoadFailure));

  @override
  LoadFailure get _value => super._value as LoadFailure;

  @override
  $Res call({
    Object cvApiFailure = freezed,
  }) {
    return _then(LoadFailure(
      cvApiFailure == freezed
          ? _value.cvApiFailure
          : cvApiFailure as CVApiFailure,
    ));
  }

  @override
  $CVApiFailureCopyWith<$Res> get cvApiFailure {
    if (_value.cvApiFailure == null) {
      return null;
    }
    return $CVApiFailureCopyWith<$Res>(_value.cvApiFailure, (value) {
      return _then(_value.copyWith(cvApiFailure: value));
    });
  }
}

class _$LoadFailure with DiagnosticableTreeMixin implements LoadFailure {
  const _$LoadFailure(this.cvApiFailure) : assert(cvApiFailure != null);

  @override
  final CVApiFailure cvApiFailure;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AbsencesState.loadFailure(cvApiFailure: $cvApiFailure)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AbsencesState.loadFailure'))
      ..add(DiagnosticsProperty('cvApiFailure', cvApiFailure));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoadFailure &&
            (identical(other.cvApiFailure, cvApiFailure) ||
                const DeepCollectionEquality()
                    .equals(other.cvApiFailure, cvApiFailure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(cvApiFailure);

  @override
  $LoadFailureCopyWith<LoadFailure> get copyWith =>
      _$LoadFailureCopyWithImpl<LoadFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(KtList<Absence> absences),
    @required Result loadFailure(CVApiFailure cvApiFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(cvApiFailure);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(KtList<Absence> absences),
    Result loadFailure(CVApiFailure cvApiFailure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(cvApiFailure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(Initial value),
    @required Result loadInProgress(LoadInProgress value),
    @required Result loadSuccess(LoadSuccess value),
    @required Result loadFailure(LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(Initial value),
    Result loadInProgress(LoadInProgress value),
    Result loadSuccess(LoadSuccess value),
    Result loadFailure(LoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(this);
    }
    return orElse();
  }
}

abstract class LoadFailure implements AbsencesState {
  const factory LoadFailure(CVApiFailure cvApiFailure) = _$LoadFailure;

  CVApiFailure get cvApiFailure;
  $LoadFailureCopyWith<LoadFailure> get copyWith;
}
